{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = exports.BaseServer = void 0;\n\nvar qs = require(\"querystring\");\n\nvar url_1 = require(\"url\");\n\nvar base64id = require(\"base64id\");\n\nvar transports_1 = require(\"./transports\");\n\nvar events_1 = require(\"events\");\n\nvar socket_1 = require(\"./socket\");\n\nvar debug_1 = require(\"debug\");\n\nvar cookie_1 = require(\"cookie\");\n\nvar ws_1 = require(\"ws\");\n\nvar debug = (0, debug_1.default)(\"engine\");\n\nvar BaseServer = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(BaseServer, _events_1$EventEmitte);\n\n  /**\n   * Server constructor.\n   *\n   * @param {Object} opts - options\n   * @api public\n   */\n  function BaseServer() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, BaseServer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseServer).call(this));\n    _this.clients = {};\n    _this.clientsCount = 0;\n    _this.opts = Object.assign({\n      wsEngine: ws_1.Server,\n      pingTimeout: 20000,\n      pingInterval: 25000,\n      upgradeTimeout: 10000,\n      maxHttpBufferSize: 1e6,\n      transports: Object.keys(transports_1.default),\n      allowUpgrades: true,\n      httpCompression: {\n        threshold: 1024\n      },\n      cors: false,\n      allowEIO3: false\n    }, opts);\n\n    if (opts.cookie) {\n      _this.opts.cookie = Object.assign({\n        name: \"io\",\n        path: \"/\",\n        // @ts-ignore\n        httpOnly: opts.cookie.path !== false,\n        sameSite: \"lax\"\n      }, opts.cookie);\n    }\n\n    if (_this.opts.cors) {\n      _this.corsMiddleware = require(\"cors\")(_this.opts.cors);\n    }\n\n    if (opts.perMessageDeflate) {\n      _this.opts.perMessageDeflate = Object.assign({\n        threshold: 1024\n      }, opts.perMessageDeflate);\n    }\n\n    _this.init();\n\n    return _this;\n  }\n  /**\n   * Returns a list of available transports for upgrade given a certain transport.\n   *\n   * @return {Array}\n   * @api public\n   */\n\n\n  _createClass(BaseServer, [{\n    key: \"upgrades\",\n    value: function upgrades(transport) {\n      if (!this.opts.allowUpgrades) return [];\n      return transports_1.default[transport].upgradesTo || [];\n    }\n    /**\n     * Verifies a request.\n     *\n     * @param {http.IncomingMessage}\n     * @return {Boolean} whether the request is valid\n     * @api private\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(req, upgrade, fn) {\n      // transport check\n      var transport = req._query.transport;\n\n      if (!~this.opts.transports.indexOf(transport)) {\n        debug('unknown transport \"%s\"', transport);\n        return fn(Server.errors.UNKNOWN_TRANSPORT, {\n          transport: transport\n        });\n      } // 'Origin' header check\n\n\n      var isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n\n      if (isOriginInvalid) {\n        var origin = req.headers.origin;\n        req.headers.origin = null;\n        debug(\"origin header invalid\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"INVALID_ORIGIN\",\n          origin: origin\n        });\n      } // sid check\n\n\n      var sid = req._query.sid;\n\n      if (sid) {\n        if (!this.clients.hasOwnProperty(sid)) {\n          debug('unknown sid \"%s\"', sid);\n          return fn(Server.errors.UNKNOWN_SID, {\n            sid: sid\n          });\n        }\n\n        var previousTransport = this.clients[sid].transport.name;\n\n        if (!upgrade && previousTransport !== transport) {\n          debug(\"bad request: unexpected transport without upgrade\");\n          return fn(Server.errors.BAD_REQUEST, {\n            name: \"TRANSPORT_MISMATCH\",\n            transport: transport,\n            previousTransport: previousTransport\n          });\n        }\n      } else {\n        // handshake is GET only\n        if (\"GET\" !== req.method) {\n          return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n            method: req.method\n          });\n        }\n\n        if (transport === \"websocket\" && !upgrade) {\n          debug(\"invalid transport upgrade\");\n          return fn(Server.errors.BAD_REQUEST, {\n            name: \"TRANSPORT_HANDSHAKE_ERROR\"\n          });\n        }\n\n        if (!this.opts.allowRequest) return fn();\n        return this.opts.allowRequest(req, function (message, success) {\n          if (!success) {\n            return fn(Server.errors.FORBIDDEN, {\n              message: message\n            });\n          }\n\n          fn();\n        });\n      }\n\n      fn();\n    }\n    /**\n     * Closes all clients.\n     *\n     * @api public\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      debug(\"closing all open clients\");\n\n      for (var i in this.clients) {\n        if (this.clients.hasOwnProperty(i)) {\n          this.clients[i].close(true);\n        }\n      }\n\n      this.cleanup();\n      return this;\n    }\n    /**\n     * generate a socket id.\n     * Overwrite this method to generate your custom socket id\n     *\n     * @param {Object} request object\n     * @api public\n     */\n\n  }, {\n    key: \"generateId\",\n    value: function generateId(req) {\n      return base64id.generateId();\n    }\n    /**\n     * Handshakes a new client.\n     *\n     * @param {String} transport name\n     * @param {Object} request object\n     * @param {Function} closeConnection\n     *\n     * @api protected\n     */\n\n  }, {\n    key: \"handshake\",\n    value: function () {\n      var _handshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(transportName, req, closeConnection) {\n        var _this2 = this;\n\n        var protocol, id, transport, socket;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n\n                if (!(protocol === 3 && !this.opts.allowEIO3)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                debug(\"unsupported protocol version\");\n                this.emit(\"connection_error\", {\n                  req: req,\n                  code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n                  message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n                  context: {\n                    protocol: protocol\n                  }\n                });\n                closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n                return _context.abrupt(\"return\");\n\n              case 6:\n                _context.prev = 6;\n                _context.next = 9;\n                return this.generateId(req);\n\n              case 9:\n                id = _context.sent;\n                _context.next = 18;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](6);\n                debug(\"error while generating an id\");\n                this.emit(\"connection_error\", {\n                  req: req,\n                  code: Server.errors.BAD_REQUEST,\n                  message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                  context: {\n                    name: \"ID_GENERATION_ERROR\",\n                    error: _context.t0\n                  }\n                });\n                closeConnection(Server.errors.BAD_REQUEST);\n                return _context.abrupt(\"return\");\n\n              case 18:\n                debug('handshaking client \"%s\"', id);\n                _context.prev = 19;\n                transport = this.createTransport(transportName, req);\n\n                if (\"polling\" === transportName) {\n                  transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n                  transport.httpCompression = this.opts.httpCompression;\n                } else if (\"websocket\" === transportName) {\n                  transport.perMessageDeflate = this.opts.perMessageDeflate;\n                }\n\n                if (req._query && req._query.b64) {\n                  transport.supportsBinary = false;\n                } else {\n                  transport.supportsBinary = true;\n                }\n\n                _context.next = 31;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t1 = _context[\"catch\"](19);\n                debug('error handshaking to transport \"%s\"', transportName);\n                this.emit(\"connection_error\", {\n                  req: req,\n                  code: Server.errors.BAD_REQUEST,\n                  message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                  context: {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                    error: _context.t1\n                  }\n                });\n                closeConnection(Server.errors.BAD_REQUEST);\n                return _context.abrupt(\"return\");\n\n              case 31:\n                socket = new socket_1.Socket(id, this, transport, req, protocol);\n                transport.on(\"headers\", function (headers, req) {\n                  var isInitialRequest = !req._query.sid;\n\n                  if (isInitialRequest) {\n                    if (_this2.opts.cookie) {\n                      headers[\"Set-Cookie\"] = [// @ts-ignore\n                      (0, cookie_1.serialize)(_this2.opts.cookie.name, id, _this2.opts.cookie)];\n                    }\n\n                    _this2.emit(\"initial_headers\", headers, req);\n                  }\n\n                  _this2.emit(\"headers\", headers, req);\n                });\n                transport.onRequest(req);\n                this.clients[id] = socket;\n                this.clientsCount++;\n                socket.once(\"close\", function () {\n                  delete _this2.clients[id];\n                  _this2.clientsCount--;\n                });\n                this.emit(\"connection\", socket);\n                return _context.abrupt(\"return\", transport);\n\n              case 39:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[6, 12], [19, 25]]);\n      }));\n\n      function handshake(_x, _x2, _x3) {\n        return _handshake.apply(this, arguments);\n      }\n\n      return handshake;\n    }()\n  }]);\n\n  return BaseServer;\n}(events_1.EventEmitter);\n\nexports.BaseServer = BaseServer;\n/**\n * Protocol errors mappings.\n */\n\nBaseServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4,\n  UNSUPPORTED_PROTOCOL_VERSION: 5\n};\nBaseServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\",\n  5: \"Unsupported protocol version\"\n};\n\nvar Server = /*#__PURE__*/function (_BaseServer) {\n  _inherits(Server, _BaseServer);\n\n  function Server() {\n    _classCallCheck(this, Server);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Server).apply(this, arguments));\n  }\n\n  _createClass(Server, [{\n    key: \"init\",\n\n    /**\n     * Initialize websocket server\n     *\n     * @api protected\n     */\n    value: function init() {\n      var _this3 = this;\n\n      if (!~this.opts.transports.indexOf(\"websocket\")) return;\n      if (this.ws) this.ws.close();\n      this.ws = new this.opts.wsEngine({\n        noServer: true,\n        clientTracking: false,\n        perMessageDeflate: this.opts.perMessageDeflate,\n        maxPayload: this.opts.maxHttpBufferSize\n      });\n\n      if (typeof this.ws.on === \"function\") {\n        this.ws.on(\"headers\", function (headersArray, req) {\n          // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n          // we could also try to parse the array and then sync the values, but that will be error-prone\n          var additionalHeaders = {};\n          var isInitialRequest = !req._query.sid;\n\n          if (isInitialRequest) {\n            _this3.emit(\"initial_headers\", additionalHeaders, req);\n          }\n\n          _this3.emit(\"headers\", additionalHeaders, req);\n\n          Object.keys(additionalHeaders).forEach(function (key) {\n            headersArray.push(\"\".concat(key, \": \").concat(additionalHeaders[key]));\n          });\n        });\n      }\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      if (this.ws) {\n        debug(\"closing webSocketServer\");\n        this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again\n      }\n    }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"prepare\",\n    value: function prepare(req) {\n      // try to leverage pre-existing `req._query` (e.g: from connect)\n      if (!req._query) {\n        req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\n      }\n    }\n  }, {\n    key: \"createTransport\",\n    value: function createTransport(transportName, req) {\n      return new transports_1.default[transportName](req);\n    }\n    /**\n     * Handles an Engine.IO HTTP request.\n     *\n     * @param {http.IncomingMessage} request\n     * @param {http.ServerResponse|http.OutgoingMessage} response\n     * @api public\n     */\n\n  }, {\n    key: \"handleRequest\",\n    value: function handleRequest(req, res) {\n      var _this4 = this;\n\n      debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n      this.prepare(req);\n      req.res = res;\n\n      var callback = function callback(errorCode, errorContext) {\n        if (errorCode !== undefined) {\n          _this4.emit(\"connection_error\", {\n            req: req,\n            code: errorCode,\n            message: Server.errorMessages[errorCode],\n            context: errorContext\n          });\n\n          abortRequest(res, errorCode, errorContext);\n          return;\n        }\n\n        if (req._query.sid) {\n          debug(\"setting new request for existing client\");\n\n          _this4.clients[req._query.sid].transport.onRequest(req);\n        } else {\n          var closeConnection = function closeConnection(errorCode, errorContext) {\n            return abortRequest(res, errorCode, errorContext);\n          };\n\n          _this4.handshake(req._query.transport, req, closeConnection);\n        }\n      };\n\n      if (this.corsMiddleware) {\n        this.corsMiddleware.call(null, req, res, function () {\n          _this4.verify(req, false, callback);\n        });\n      } else {\n        this.verify(req, false, callback);\n      }\n    }\n    /**\n     * Handles an Engine.IO HTTP Upgrade.\n     *\n     * @api public\n     */\n\n  }, {\n    key: \"handleUpgrade\",\n    value: function handleUpgrade(req, socket, upgradeHead) {\n      var _this5 = this;\n\n      this.prepare(req);\n      this.verify(req, true, function (errorCode, errorContext) {\n        if (errorCode) {\n          _this5.emit(\"connection_error\", {\n            req: req,\n            code: errorCode,\n            message: Server.errorMessages[errorCode],\n            context: errorContext\n          });\n\n          abortUpgrade(socket, errorCode, errorContext);\n          return;\n        }\n\n        var head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n\n        upgradeHead = null; // delegate to ws\n\n        _this5.ws.handleUpgrade(req, socket, head, function (websocket) {\n          _this5.onWebSocket(req, socket, websocket);\n        });\n      });\n    }\n    /**\n     * Called upon a ws.io connection.\n     *\n     * @param {ws.Socket} websocket\n     * @api private\n     */\n\n  }, {\n    key: \"onWebSocket\",\n    value: function onWebSocket(req, socket, websocket) {\n      websocket.on(\"error\", onUpgradeError);\n\n      if (transports_1.default[req._query.transport] !== undefined && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n        debug(\"transport doesnt handle upgraded requests\");\n        websocket.close();\n        return;\n      } // get client id\n\n\n      var id = req._query.sid; // keep a reference to the ws.Socket\n\n      req.websocket = websocket;\n\n      if (id) {\n        var client = this.clients[id];\n\n        if (!client) {\n          debug(\"upgrade attempt for closed client\");\n          websocket.close();\n        } else if (client.upgrading) {\n          debug(\"transport has already been trying to upgrade\");\n          websocket.close();\n        } else if (client.upgraded) {\n          debug(\"transport had already been upgraded\");\n          websocket.close();\n        } else {\n          debug(\"upgrading existing transport\"); // transport error handling takes over\n\n          websocket.removeListener(\"error\", onUpgradeError);\n          var transport = this.createTransport(req._query.transport, req);\n\n          if (req._query && req._query.b64) {\n            transport.supportsBinary = false;\n          } else {\n            transport.supportsBinary = true;\n          }\n\n          transport.perMessageDeflate = this.opts.perMessageDeflate;\n          client.maybeUpgrade(transport);\n        }\n      } else {\n        var closeConnection = function closeConnection(errorCode, errorContext) {\n          return abortUpgrade(socket, errorCode, errorContext);\n        };\n\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n\n      function onUpgradeError() {\n        debug(\"websocket error before upgrade\"); // websocket.close() not needed\n      }\n    }\n    /**\n     * Captures upgrade requests for a http.Server.\n     *\n     * @param {http.Server} server\n     * @param {Object} options\n     * @api public\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(server) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n      var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000; // normalize path\n\n      path += \"/\";\n\n      function check(req) {\n        return path === req.url.substr(0, path.length);\n      } // cache and clean up listeners\n\n\n      var listeners = server.listeners(\"request\").slice(0);\n      server.removeAllListeners(\"request\");\n      server.on(\"close\", this.close.bind(this));\n      server.on(\"listening\", this.init.bind(this)); // add request handler\n\n      server.on(\"request\", function (req, res) {\n        if (check(req)) {\n          debug('intercepting request for path \"%s\"', path);\n\n          _this6.handleRequest(req, res);\n        } else {\n          var i = 0;\n          var l = listeners.length;\n\n          for (; i < l; i++) {\n            listeners[i].call(server, req, res);\n          }\n        }\n      });\n\n      if (~this.opts.transports.indexOf(\"websocket\")) {\n        server.on(\"upgrade\", function (req, socket, head) {\n          if (check(req)) {\n            _this6.handleUpgrade(req, socket, head);\n          } else if (false !== options.destroyUpgrade) {\n            // default node behavior is to disconnect when no handlers\n            // but by adding a handler, we prevent that\n            // and if no eio thing handles the upgrade\n            // then the socket needs to die!\n            setTimeout(function () {\n              // @ts-ignore\n              if (socket.writable && socket.bytesWritten <= 0) {\n                return socket.end();\n              }\n            }, destroyUpgradeTimeout);\n          }\n        });\n      }\n    }\n  }]);\n\n  return Server;\n}(BaseServer);\n\nexports.Server = Server;\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  var statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  var message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];\n  res.writeHead(statusCode, {\n    \"Content-Type\": \"application/json\"\n  });\n  res.end(JSON.stringify({\n    code: errorCode,\n    message: message\n  }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\n\n\nfunction abortUpgrade(socket, errorCode) {\n  var errorContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  socket.on(\"error\", function () {\n    debug(\"ignoring error from closed connection\");\n  });\n\n  if (socket.writable) {\n    var message = errorContext.message || Server.errorMessages[errorCode];\n    var length = Buffer.byteLength(message);\n    socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + \"Content-Length: \" + length + \"\\r\\n\" + \"\\r\\n\" + message);\n  }\n\n  socket.destroy();\n}\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\n\n\nvar validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n\n  if (val.length < 2) return false;\n\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n\n  if (val.length < 3) return false;\n\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n\n  if (val.length < 4) return false;\n\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n\n  for (var i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"script"}