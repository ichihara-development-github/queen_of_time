{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParentNamespace = void 0;\n\nvar namespace_1 = require(\"./namespace\");\n\nvar ParentNamespace = /*#__PURE__*/function (_namespace_1$Namespac) {\n  _inherits(ParentNamespace, _namespace_1$Namespac);\n\n  function ParentNamespace(server) {\n    var _this;\n\n    _classCallCheck(this, ParentNamespace);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ParentNamespace).call(this, server, \"/_\" + ParentNamespace.count++));\n    _this.children = new Set();\n    return _this;\n  }\n  /**\n   * @private\n   */\n\n\n  _createClass(ParentNamespace, [{\n    key: \"_initAdapter\",\n    value: function _initAdapter() {\n      var _this2 = this;\n\n      var broadcast = function broadcast(packet, opts) {\n        _this2.children.forEach(function (nsp) {\n          nsp.adapter.broadcast(packet, opts);\n        });\n      }; // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n\n\n      this.adapter = {\n        broadcast: broadcast\n      };\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(ev) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      this.children.forEach(function (nsp) {\n        nsp.emit.apply(nsp, [ev].concat(args));\n      });\n      return true;\n    }\n  }, {\n    key: \"createChild\",\n    value: function createChild(name) {\n      var namespace = new namespace_1.Namespace(this.server, name);\n      namespace._fns = this._fns.slice(0);\n      this.listeners(\"connect\").forEach(function (listener) {\n        return namespace.on(\"connect\", listener);\n      });\n      this.listeners(\"connection\").forEach(function (listener) {\n        return namespace.on(\"connection\", listener);\n      });\n      this.children.add(namespace);\n\n      this.server._nsps.set(name, namespace);\n\n      return namespace;\n    }\n  }, {\n    key: \"fetchSockets\",\n    value: function fetchSockets() {\n      // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n      // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n      // the behavior for namespaces created with a function is less clear\n      // noteÂ²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n      // may exist on one node but not exist on another (since it is created upon client connection)\n      throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n  }]);\n\n  return ParentNamespace;\n}(namespace_1.Namespace);\n\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;","map":null,"metadata":{},"sourceType":"script"}