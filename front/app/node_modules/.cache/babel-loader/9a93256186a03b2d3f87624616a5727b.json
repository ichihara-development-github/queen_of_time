{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serveFile = exports.restoreAdapter = exports.patchAdapter = void 0;\n\nvar socket_io_adapter_1 = require(\"socket.io-adapter\");\n\nvar fs_1 = require(\"fs\");\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar debug = (0, debug_1.default)(\"socket.io:adapter-uws\");\nvar SEPARATOR = \"\\x1f\"; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\n\nvar _socket_io_adapter_1$ = socket_io_adapter_1.Adapter.prototype,\n    addAll = _socket_io_adapter_1$.addAll,\n    del = _socket_io_adapter_1$.del,\n    broadcast = _socket_io_adapter_1$.broadcast;\n\nfunction patchAdapter(app\n/* : TemplatedApp */\n) {\n  socket_io_adapter_1.Adapter.prototype.addAll = function (id, rooms) {\n    var _this = this;\n\n    var isNew = !this.sids.has(id);\n    addAll.call(this, id, rooms);\n    var socket = this.nsp.sockets.get(id);\n\n    if (!socket) {\n      return;\n    }\n\n    if (socket.conn.transport.name === \"websocket\") {\n      subscribe(this.nsp.name, socket, isNew, rooms);\n      return;\n    }\n\n    if (isNew) {\n      socket.conn.on(\"upgrade\", function () {\n        var rooms = _this.sids.get(id);\n\n        if (rooms) {\n          subscribe(_this.nsp.name, socket, isNew, rooms);\n        }\n      });\n    }\n  };\n\n  socket_io_adapter_1.Adapter.prototype.del = function (id, room) {\n    del.call(this, id, room);\n    var socket = this.nsp.sockets.get(id);\n\n    if (socket && socket.conn.transport.name === \"websocket\") {\n      // @ts-ignore\n      var sessionId = socket.conn.id; // @ts-ignore\n\n      var websocket = socket.conn.transport.socket;\n      var topic = \"\".concat(this.nsp.name).concat(SEPARATOR).concat(room);\n      debug(\"unsubscribe connection %s from topic %s\", sessionId, topic);\n      websocket.unsubscribe(topic);\n    }\n  };\n\n  socket_io_adapter_1.Adapter.prototype.broadcast = function (packet, opts) {\n    var useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;\n\n    if (!useFastPublish) {\n      broadcast.call(this, packet, opts);\n      return;\n    }\n\n    var flags = opts.flags || {};\n    var basePacketOpts = {\n      preEncoded: true,\n      volatile: flags.volatile,\n      compress: flags.compress\n    };\n    packet.nsp = this.nsp.name;\n    var encodedPackets = this.encoder.encode(packet);\n    var topic = opts.rooms.size === 0 ? this.nsp.name : \"\".concat(this.nsp.name).concat(SEPARATOR).concat(opts.rooms.keys().next().value);\n    debug(\"fast publish to %s\", topic); // fast publish for clients connected with WebSocket\n\n    encodedPackets.forEach(function (encodedPacket) {\n      var isBinary = typeof encodedPacket !== \"string\"; // \"4\" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol\n\n      app.publish(topic, isBinary ? encodedPacket : \"4\" + encodedPacket, isBinary);\n    });\n    this.apply(opts, function (socket) {\n      if (socket.conn.transport.name !== \"websocket\") {\n        // classic publish for clients connected with HTTP long-polling\n        socket.client.writeToEngine(encodedPackets, basePacketOpts);\n      }\n    });\n  };\n}\n\nexports.patchAdapter = patchAdapter;\n\nfunction subscribe(namespaceName, socket, isNew, rooms) {\n  // @ts-ignore\n  var sessionId = socket.conn.id; // @ts-ignore\n\n  var websocket = socket.conn.transport.socket;\n\n  if (isNew) {\n    debug(\"subscribe connection %s to topic %s\", sessionId, namespaceName);\n    websocket.subscribe(namespaceName);\n  }\n\n  rooms.forEach(function (room) {\n    var topic = \"\".concat(namespaceName).concat(SEPARATOR).concat(room); // '#' can be used as wildcard\n\n    debug(\"subscribe connection %s to topic %s\", sessionId, topic);\n    websocket.subscribe(topic);\n  });\n}\n\nfunction restoreAdapter() {\n  socket_io_adapter_1.Adapter.prototype.addAll = addAll;\n  socket_io_adapter_1.Adapter.prototype.del = del;\n  socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;\n}\n\nexports.restoreAdapter = restoreAdapter;\n\nvar toArrayBuffer = function toArrayBuffer(buffer) {\n  var arrayBuffer = buffer.buffer,\n      byteOffset = buffer.byteOffset,\n      byteLength = buffer.byteLength;\n  return arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n}; // imported from https://github.com/kolodziejczak-sz/uwebsocket-serve\n\n\nfunction serveFile(res\n/* : HttpResponse */\n, filepath) {\n  var _ref = (0, fs_1.statSync)(filepath),\n      size = _ref.size;\n\n  var readStream = (0, fs_1.createReadStream)(filepath);\n\n  var destroyReadStream = function destroyReadStream() {\n    return !readStream.destroyed && readStream.destroy();\n  };\n\n  var onError = function onError(error) {\n    destroyReadStream();\n    throw error;\n  };\n\n  var onDataChunk = function onDataChunk(chunk) {\n    var arrayBufferChunk = toArrayBuffer(chunk);\n    var lastOffset = res.getWriteOffset();\n\n    var _res$tryEnd = res.tryEnd(arrayBufferChunk, size),\n        _res$tryEnd2 = _slicedToArray(_res$tryEnd, 2),\n        ok = _res$tryEnd2[0],\n        done = _res$tryEnd2[1];\n\n    if (!done && !ok) {\n      readStream.pause();\n      res.onWritable(function (offset) {\n        var _res$tryEnd3 = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size),\n            _res$tryEnd4 = _slicedToArray(_res$tryEnd3, 2),\n            ok = _res$tryEnd4[0],\n            done = _res$tryEnd4[1];\n\n        if (!done && ok) {\n          readStream.resume();\n        }\n\n        return ok;\n      });\n    }\n  };\n\n  res.onAborted(destroyReadStream);\n  readStream.on(\"data\", onDataChunk).on(\"error\", onError).on(\"end\", destroyReadStream);\n}\n\nexports.serveFile = serveFile;","map":null,"metadata":{},"sourceType":"script"}