{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\n\nvar socket_io_parser_1 = require(\"socket.io-parser\");\n\nvar debugModule = require(\"debug\");\n\nvar url = require(\"url\");\n\nvar debug = debugModule(\"socket.io:client\");\n\nvar Client = /*#__PURE__*/function () {\n  /**\n   * Client constructor.\n   *\n   * @param server instance\n   * @param conn\n   * @package\n   */\n  function Client(server, conn) {\n    _classCallCheck(this, Client);\n\n    this.sockets = new Map();\n    this.nsps = new Map();\n    this.server = server;\n    this.conn = conn;\n    this.encoder = server.encoder;\n    this.decoder = new server._parser.Decoder();\n    this.id = conn.id;\n    this.setup();\n  }\n  /**\n   * @return the reference to the request that originated the Engine.IO connection\n   *\n   * @public\n   */\n\n\n  _createClass(Client, [{\n    key: \"setup\",\n\n    /**\n     * Sets up event listeners.\n     *\n     * @private\n     */\n    value: function setup() {\n      var _this = this;\n\n      this.onclose = this.onclose.bind(this);\n      this.ondata = this.ondata.bind(this);\n      this.onerror = this.onerror.bind(this);\n      this.ondecoded = this.ondecoded.bind(this); // @ts-ignore\n\n      this.decoder.on(\"decoded\", this.ondecoded);\n      this.conn.on(\"data\", this.ondata);\n      this.conn.on(\"error\", this.onerror);\n      this.conn.on(\"close\", this.onclose);\n      this.connectTimeout = setTimeout(function () {\n        if (_this.nsps.size === 0) {\n          debug(\"no namespace joined yet, close the client\");\n\n          _this.close();\n        } else {\n          debug(\"the client has already joined a namespace, nothing to do\");\n        }\n      }, this.server._connectTimeout);\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param {String} name - the namespace\n     * @param {Object} auth - the auth parameters\n     * @private\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(name) {\n      var _this2 = this;\n\n      var auth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.server._nsps.has(name)) {\n        debug(\"connecting to namespace %s\", name);\n        return this.doConnect(name, auth);\n      }\n\n      this.server._checkNamespace(name, auth, function (dynamicNspName) {\n        if (dynamicNspName) {\n          _this2.doConnect(name, auth);\n        } else {\n          debug(\"creation of namespace %s was denied\", name);\n\n          _this2._packet({\n            type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n            nsp: name,\n            data: {\n              message: \"Invalid namespace\"\n            }\n          });\n        }\n      });\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param name - the namespace\n     * @param {Object} auth - the auth parameters\n     *\n     * @private\n     */\n\n  }, {\n    key: \"doConnect\",\n    value: function doConnect(name, auth) {\n      var _this3 = this;\n\n      var nsp = this.server.of(name);\n\n      var socket = nsp._add(this, auth, function () {\n        _this3.sockets.set(socket.id, socket);\n\n        _this3.nsps.set(nsp.name, socket);\n\n        if (_this3.connectTimeout) {\n          clearTimeout(_this3.connectTimeout);\n          _this3.connectTimeout = undefined;\n        }\n      });\n    }\n    /**\n     * Disconnects from all namespaces and closes transport.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_disconnect\",\n    value: function _disconnect() {\n      var _iterator = _createForOfIteratorHelper(this.sockets.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var socket = _step.value;\n          socket.disconnect();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.sockets.clear();\n      this.close();\n    }\n    /**\n     * Removes a socket. Called by each `Socket`.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(socket) {\n      if (this.sockets.has(socket.id)) {\n        var nsp = this.sockets.get(socket.id).nsp.name;\n        this.sockets.delete(socket.id);\n        this.nsps.delete(nsp);\n      } else {\n        debug(\"ignoring remove for %s\", socket.id);\n      }\n    }\n    /**\n     * Closes the underlying connection.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (\"open\" === this.conn.readyState) {\n        debug(\"forcing transport close\");\n        this.conn.close();\n        this.onclose(\"forced server close\");\n      }\n    }\n    /**\n     * Writes a packet to the transport.\n     *\n     * @param {Object} packet object\n     * @param {Object} opts\n     * @private\n     */\n\n  }, {\n    key: \"_packet\",\n    value: function _packet(packet) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.conn.readyState !== \"open\") {\n        debug(\"ignoring packet write %j\", packet);\n        return;\n      }\n\n      var encodedPackets = opts.preEncoded ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()\n      : this.encoder.encode(packet);\n      this.writeToEngine(encodedPackets, opts);\n    }\n  }, {\n    key: \"writeToEngine\",\n    value: function writeToEngine(encodedPackets, opts) {\n      if (opts.volatile && !this.conn.transport.writable) {\n        debug(\"volatile packet is discarded since the transport is not currently writable\");\n        return;\n      }\n\n      var packets = Array.isArray(encodedPackets) ? encodedPackets : [encodedPackets];\n\n      var _iterator2 = _createForOfIteratorHelper(packets),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var encodedPacket = _step2.value;\n          this.conn.write(encodedPacket, opts);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Called with incoming transport data.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"ondata\",\n    value: function ondata(data) {\n      // try/catch is needed for protocol violations (GH-1880)\n      try {\n        this.decoder.add(data);\n      } catch (e) {\n        debug(\"invalid packet format\");\n        this.onerror(e);\n      }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"ondecoded\",\n    value: function ondecoded(packet) {\n      var namespace;\n      var authPayload;\n\n      if (this.conn.protocol === 3) {\n        var parsed = url.parse(packet.nsp, true);\n        namespace = parsed.pathname;\n        authPayload = parsed.query;\n      } else {\n        namespace = packet.nsp;\n        authPayload = packet.data;\n      }\n\n      var socket = this.nsps.get(namespace);\n\n      if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {\n        this.connect(namespace, authPayload);\n      } else if (socket && packet.type !== socket_io_parser_1.PacketType.CONNECT && packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {\n        process.nextTick(function () {\n          socket._onpacket(packet);\n        });\n      } else {\n        debug(\"invalid state (packet type: %s)\", packet.type);\n        this.close();\n      }\n    }\n    /**\n     * Handles an error.\n     *\n     * @param {Object} err object\n     * @private\n     */\n\n  }, {\n    key: \"onerror\",\n    value: function onerror(err) {\n      var _iterator3 = _createForOfIteratorHelper(this.sockets.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var socket = _step3.value;\n\n          socket._onerror(err);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this.conn.close();\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @param reason\n     * @private\n     */\n\n  }, {\n    key: \"onclose\",\n    value: function onclose(reason) {\n      debug(\"client close with reason %s\", reason); // ignore a potential subsequent `close` event\n\n      this.destroy(); // `nsps` and `sockets` are cleaned up seamlessly\n\n      var _iterator4 = _createForOfIteratorHelper(this.sockets.values()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var socket = _step4.value;\n\n          socket._onclose(reason);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this.sockets.clear();\n      this.decoder.destroy(); // clean up decoder\n    }\n    /**\n     * Cleans up event listeners.\n     * @private\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.conn.removeListener(\"data\", this.ondata);\n      this.conn.removeListener(\"error\", this.onerror);\n      this.conn.removeListener(\"close\", this.onclose); // @ts-ignore\n\n      this.decoder.removeListener(\"decoded\", this.ondecoded);\n\n      if (this.connectTimeout) {\n        clearTimeout(this.connectTimeout);\n        this.connectTimeout = undefined;\n      }\n    }\n  }, {\n    key: \"request\",\n    get: function get() {\n      return this.conn.request;\n    }\n  }]);\n\n  return Client;\n}();\n\nexports.Client = Client;","map":null,"metadata":{},"sourceType":"script"}