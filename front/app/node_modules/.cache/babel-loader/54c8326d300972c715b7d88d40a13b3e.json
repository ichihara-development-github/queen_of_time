{"ast":null,"code":"import _toConsumableArray from \"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getMonthsInYear } from '../../utils/date-utils';\nexport var getDateSectionConfigFromFormatToken = function getDateSectionConfigFromFormatToken(utils, formatToken) {\n  var config = utils.formatTokenMap[formatToken];\n\n  if (config == null) {\n    throw new Error([\"MUI: The token \\\"\".concat(formatToken, \"\\\" is not supported by the Date and Time Pickers.\"), 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit',\n      maxLength: undefined\n    };\n  }\n\n  return {\n    type: config.sectionType,\n    contentType: config.contentType,\n    maxLength: config.maxLength\n  };\n};\n\nvar getDeltaFromKeyCode = function getDeltaFromKeyCode(keyCode) {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n\n    case 'ArrowDown':\n      return -1;\n\n    case 'PageUp':\n      return 5;\n\n    case 'PageDown':\n      return -5;\n\n    default:\n      return 0;\n  }\n};\n\nexport var getDaysInWeekStr = function getDaysInWeekStr(utils, timezone, format) {\n  var elements = [];\n  var now = utils.dateWithTimezone(undefined, timezone);\n  var startDate = utils.startOfWeek(now);\n  var endDate = utils.endOfWeek(now);\n  var current = startDate;\n\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n\n  return elements.map(function (weekDay) {\n    return utils.formatByString(weekDay, format);\n  });\n};\nexport var getLetterEditingOptions = function getLetterEditingOptions(utils, timezone, sectionType, format) {\n  switch (sectionType) {\n    case 'month':\n      {\n        return getMonthsInYear(utils, utils.dateWithTimezone(undefined, timezone)).map(function (month) {\n          return utils.formatByString(month, format);\n        });\n      }\n\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, timezone, format);\n      }\n\n    case 'meridiem':\n      {\n        var now = utils.dateWithTimezone(undefined, timezone);\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(function (date) {\n          return utils.formatByString(date, format);\n        });\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\nexport var cleanLeadingZeros = function cleanLeadingZeros(utils, valueStr, size) {\n  var cleanValueStr = valueStr; // Remove the leading zeros\n\n  cleanValueStr = Number(cleanValueStr).toString(); // Add enough leading zeros to fill the section\n\n  while (cleanValueStr.length < size) {\n    cleanValueStr = \"0\".concat(cleanValueStr);\n  }\n\n  return cleanValueStr;\n};\nexport var cleanDigitSectionValue = function cleanDigitSectionValue(utils, timezone, value, sectionBoundaries, section) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (section.type !== 'day' && section.contentType === 'digit-with-letter') {\n      throw new Error([\"MUI: The token \\\"\".concat(section.format, \"\\\" is a digit format with letter in it.'\\n             This type of format is only supported for 'day' sections\")].join('\\n'));\n    }\n  }\n\n  if (section.type === 'day' && section.contentType === 'digit-with-letter') {\n    var date = utils.setDate(sectionBoundaries.longestMonth, value);\n    return utils.formatByString(date, section.format);\n  } // queryValue without leading `0` (`01` => `1`)\n\n\n  var valueStr = value.toString();\n\n  if (section.hasLeadingZerosInInput) {\n    return cleanLeadingZeros(utils, valueStr, section.maxLength);\n  }\n\n  return valueStr;\n};\nexport var adjustSectionValue = function adjustSectionValue(utils, timezone, section, keyCode, sectionsValueBoundaries, activeDate, stepsAttributes) {\n  var delta = getDeltaFromKeyCode(keyCode);\n  var isStart = keyCode === 'Home';\n  var isEnd = keyCode === 'End';\n  var shouldSetAbsolute = section.value === '' || isStart || isEnd;\n\n  var adjustDigitSection = function adjustDigitSection() {\n    var sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n\n    var getCleanValue = function getCleanValue(value) {\n      return cleanDigitSectionValue(utils, timezone, value, sectionBoundaries, section);\n    };\n\n    var step = section.type === 'minutes' && stepsAttributes != null && stepsAttributes.minutesStep ? stepsAttributes.minutesStep : 1;\n    var currentSectionValue = parseInt(section.value, 10);\n    var newSectionValueNumber = currentSectionValue + delta * step;\n\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.dateWithTimezone(undefined, timezone), section.format);\n      }\n\n      if (delta > 0 || isStart) {\n        newSectionValueNumber = sectionBoundaries.minimum;\n      } else {\n        newSectionValueNumber = sectionBoundaries.maximum;\n      }\n    }\n\n    if (newSectionValueNumber % step !== 0) {\n      if (delta < 0 || isStart) {\n        newSectionValueNumber += step - (step + newSectionValueNumber) % step; // for JS -3 % 5 = -3 (should be 2)\n      }\n\n      if (delta > 0 || isEnd) {\n        newSectionValueNumber -= newSectionValueNumber % step;\n      }\n    }\n\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n\n    return getCleanValue(newSectionValueNumber);\n  };\n\n  var adjustLetterSection = function adjustLetterSection() {\n    var options = getLetterEditingOptions(utils, timezone, section.type, section.format);\n\n    if (options.length === 0) {\n      return section.value;\n    }\n\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n\n      return options[options.length - 1];\n    }\n\n    var currentOptionIndex = options.indexOf(section.value);\n    var newOptionIndex = (currentOptionIndex + options.length + delta) % options.length;\n    return options[newOptionIndex];\n  };\n\n  if (section.contentType === 'digit' || section.contentType === 'digit-with-letter') {\n    return adjustDigitSection();\n  }\n\n  return adjustLetterSection();\n};\nexport var getSectionVisibleValue = function getSectionVisibleValue(section, target) {\n  var value = section.value || section.placeholder;\n  var hasLeadingZeros = target === 'non-input' ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;\n\n  if (target === 'non-input' && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {\n    value = Number(value).toString();\n  } // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n\n\n  var shouldAddInvisibleSpace = ['input-rtl', 'input-ltr'].includes(target) && section.contentType === 'digit' && !hasLeadingZeros && value.length === 1;\n\n  if (shouldAddInvisibleSpace) {\n    value = \"\".concat(value, \"\\u200E\");\n  }\n\n  if (target === 'input-rtl') {\n    value = \"\\u2068\".concat(value, \"\\u2069\");\n  }\n\n  return value;\n};\nexport var cleanString = function cleanString(dirtyString) {\n  return dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\n};\nexport var addPositionPropertiesToSections = function addPositionPropertiesToSections(sections, isRTL) {\n  var position = 0;\n  var positionInInput = isRTL ? 1 : 0;\n  var newSections = [];\n\n  for (var i = 0; i < sections.length; i += 1) {\n    var section = sections[i];\n    var renderedValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr');\n    var sectionStr = \"\".concat(section.startSeparator).concat(renderedValue).concat(section.endSeparator);\n    var sectionLength = cleanString(sectionStr).length;\n    var sectionLengthInInput = sectionStr.length; // The ...InInput values consider the unicode characters but do include them in their indexes\n\n    var cleanedValue = cleanString(renderedValue);\n    var startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;\n    var endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput: startInInput,\n      endInInput: endInInput\n    }));\n    position += sectionLength; // Move position to the end of string associated to the current section\n\n    positionInInput += sectionLengthInInput;\n  }\n\n  return newSections;\n};\n\nvar getSectionPlaceholder = function getSectionPlaceholder(utils, timezone, localeText, sectionConfig, currentTokenValue) {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.dateWithTimezone(undefined, timezone), currentTokenValue).length\n        });\n      }\n\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder();\n      }\n\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder();\n      }\n\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder();\n      }\n\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder();\n      }\n\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder();\n      }\n\n    default:\n      {\n        return currentTokenValue;\n      }\n  }\n};\n\nexport var changeSectionValueFormat = function changeSectionValueFormat(utils, valueStr, currentFormat, newFormat) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\n\nvar isFourDigitYearFormat = function isFourDigitYearFormat(utils, timezone, format) {\n  return utils.formatByString(utils.dateWithTimezone(undefined, timezone), format).length === 4;\n};\n\nexport var doesSectionFormatHaveLeadingZeros = function doesSectionFormatHaveLeadingZeros(utils, timezone, contentType, sectionType, format) {\n  if (contentType !== 'digit') {\n    return false;\n  }\n\n  var now = utils.dateWithTimezone(undefined, timezone);\n\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        if (isFourDigitYearFormat(utils, timezone, format)) {\n          var formatted0001 = utils.formatByString(utils.setYear(now, 1), format);\n          return formatted0001 === '0001';\n        }\n\n        var formatted2001 = utils.formatByString(utils.setYear(now, 2001), format);\n        return formatted2001 === '01';\n      }\n\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(now), format).length > 1;\n      }\n\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(now), format).length > 1;\n      }\n\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(now), format).length > 1;\n      }\n\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(now, 1), format).length > 1;\n      }\n\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;\n      }\n\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;\n      }\n\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\n\nvar getEscapedPartsFromFormat = function getEscapedPartsFromFormat(utils, format) {\n  var escapedParts = [];\n  var _utils$escapedCharact = utils.escapedCharacters,\n      startChar = _utils$escapedCharact.start,\n      endChar = _utils$escapedCharact.end;\n  var regExp = new RegExp(\"(\\\\\".concat(startChar, \"[^\\\\\").concat(endChar, \"]*\\\\\").concat(endChar, \")+\"), 'g');\n  var match = null; // eslint-disable-next-line no-cond-assign\n\n  while (match = regExp.exec(format)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n\n  return escapedParts;\n};\n\nexport var splitFormatIntoSections = function splitFormatIntoSections(utils, timezone, localeText, format, date, formatDensity, shouldRespectLeadingZeros, isRTL) {\n  var startSeparator = '';\n  var sections = [];\n  var now = utils.date();\n\n  var commitToken = function commitToken(token) {\n    if (token === '') {\n      return null;\n    }\n\n    var sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n    var hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, timezone, sectionConfig.contentType, sectionConfig.type, token);\n    var hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\n    var isValidDate = date != null && utils.isValid(date);\n    var sectionValue = isValidDate ? utils.formatByString(date, token) : '';\n    var maxLength = null;\n\n    if (hasLeadingZerosInInput) {\n      if (hasLeadingZerosInFormat) {\n        maxLength = sectionValue === '' ? utils.formatByString(now, token).length : sectionValue.length;\n      } else {\n        if (sectionConfig.maxLength == null) {\n          throw new Error(\"MUI: The token \".concat(token, \" should have a 'maxDigitNumber' property on it's adapter\"));\n        }\n\n        maxLength = sectionConfig.maxLength;\n\n        if (isValidDate) {\n          sectionValue = cleanLeadingZeros(utils, sectionValue, maxLength);\n        }\n      }\n    }\n\n    sections.push(_extends({}, sectionConfig, {\n      format: token,\n      maxLength: maxLength,\n      value: sectionValue,\n      placeholder: getSectionPlaceholder(utils, timezone, localeText, sectionConfig, token),\n      hasLeadingZeros: hasLeadingZerosInFormat,\n      hasLeadingZerosInFormat: hasLeadingZerosInFormat,\n      hasLeadingZerosInInput: hasLeadingZerosInInput,\n      startSeparator: sections.length === 0 ? startSeparator : '',\n      endSeparator: '',\n      modified: false\n    }));\n    return null;\n  }; // Expand the provided format\n\n\n  var formatExpansionOverflow = 10;\n  var prevFormat = format;\n  var nextFormat = utils.expandFormat(format);\n\n  while (nextFormat !== prevFormat) {\n    prevFormat = nextFormat;\n    nextFormat = utils.expandFormat(prevFormat);\n    formatExpansionOverflow -= 1;\n\n    if (formatExpansionOverflow < 0) {\n      throw new Error('MUI: The format expansion seems to be  enter in an infinite loop. Please open an issue with the format passed to the picker component');\n    }\n  }\n\n  var expandedFormat = nextFormat; // Get start/end indexes of escaped sections\n\n  var escapedParts = getEscapedPartsFromFormat(utils, expandedFormat); // This RegExp test if the beginning of a string correspond to a supported token\n\n  var isTokenStartRegExp = new RegExp(\"^(\".concat(Object.keys(utils.formatTokenMap).join('|'), \")\"));\n  var currentTokenValue = '';\n\n  var _loop = function _loop(i) {\n    var escapedPartOfCurrentChar = escapedParts.find(function (escapeIndex) {\n      return escapeIndex.start <= i && escapeIndex.end >= i;\n    });\n    var char = expandedFormat[i];\n    var isEscapedChar = escapedPartOfCurrentChar != null;\n    var potentialToken = \"\".concat(currentTokenValue).concat(expandedFormat.slice(i));\n\n    if (!isEscapedChar && char.match(/([A-Za-z]+)/) && isTokenStartRegExp.test(potentialToken)) {\n      currentTokenValue += char;\n    } else {\n      // If we are on the opening or closing character of an escaped part of the format,\n      // Then we ignore this character.\n      var isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;\n\n      if (!isEscapeBoundary) {\n        commitToken(currentTokenValue);\n        currentTokenValue = '';\n\n        if (sections.length === 0) {\n          startSeparator += char;\n        } else {\n          sections[sections.length - 1].endSeparator += char;\n        }\n      }\n    }\n  };\n\n  for (var i = 0; i < expandedFormat.length; i += 1) {\n    _loop(i);\n  }\n\n  commitToken(currentTokenValue);\n  return sections.map(function (section) {\n    var cleanSeparator = function cleanSeparator(separator) {\n      var cleanedSeparator = separator;\n\n      if (isRTL && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = \"\\u2069\".concat(cleanedSeparator, \"\\u2066\");\n      }\n\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\n        cleanedSeparator = \" \".concat(cleanedSeparator, \" \");\n      }\n\n      return cleanedSeparator;\n    };\n\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\n\nexport var getDateFromDateSections = function getDateFromDateSections(utils, sections) {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  var shouldSkipWeekDays = sections.some(function (section) {\n    return section.type === 'day';\n  });\n  var sectionFormats = [];\n  var sectionValues = [];\n\n  for (var i = 0; i < sections.length; i += 1) {\n    var section = sections[i];\n    var shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, 'non-input'));\n    }\n  }\n\n  var formatWithoutSeparator = sectionFormats.join(' ');\n  var dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport var createDateStrForInputFromSections = function createDateStrForInputFromSections(sections, isRTL) {\n  var formattedSections = sections.map(function (section) {\n    var dateValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr');\n    return \"\".concat(section.startSeparator).concat(dateValue).concat(section.endSeparator);\n  });\n  var dateStr = formattedSections.join('');\n\n  if (!isRTL) {\n    return dateStr;\n  } // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n\n\n  return \"\\u2066\".concat(dateStr, \"\\u2069\");\n};\nexport var getSectionsBoundaries = function getSectionsBoundaries(utils, timezone) {\n  var today = utils.dateWithTimezone(undefined, timezone);\n  var endOfYear = utils.endOfYear(today);\n  var endOfDay = utils.endOfDay(today);\n\n  var _getMonthsInYear$redu = getMonthsInYear(utils, today).reduce(function (acc, month) {\n    var daysInMonth = utils.getDaysInMonth(month);\n\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  }),\n      maxDaysInMonth = _getMonthsInYear$redu.maxDaysInMonth,\n      longestMonth = _getMonthsInYear$redu.longestMonth;\n\n  return {\n    year: function year(_ref) {\n      var format = _ref.format;\n      return {\n        minimum: 0,\n        maximum: isFourDigitYearFormat(utils, timezone, format) ? 9999 : 99\n      };\n    },\n    month: function month() {\n      return {\n        minimum: 1,\n        // Assumption: All years have the same amount of months\n        maximum: utils.getMonth(endOfYear) + 1\n      };\n    },\n    day: function day(_ref2) {\n      var currentDate = _ref2.currentDate;\n      return {\n        minimum: 1,\n        maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,\n        longestMonth: longestMonth\n      };\n    },\n    weekDay: function weekDay(_ref3) {\n      var format = _ref3.format,\n          contentType = _ref3.contentType;\n\n      if (contentType === 'digit') {\n        var daysInWeek = getDaysInWeekStr(utils, timezone, format).map(Number);\n        return {\n          minimum: Math.min.apply(Math, _toConsumableArray(daysInWeek)),\n          maximum: Math.max.apply(Math, _toConsumableArray(daysInWeek))\n        };\n      }\n\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: function hours(_ref4) {\n      var format = _ref4.format;\n      var lastHourInDay = utils.getHours(endOfDay);\n      var hasMeridiem = utils.formatByString(utils.endOfDay(today), format) !== lastHourInDay.toString();\n\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(utils.formatByString(utils.startOfDay(today), format))\n        };\n      }\n\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: function minutes() {\n      return {\n        minimum: 0,\n        // Assumption: All years have the same amount of minutes\n        maximum: utils.getMinutes(endOfDay)\n      };\n    },\n    seconds: function seconds() {\n      return {\n        minimum: 0,\n        // Assumption: All years have the same amount of seconds\n        maximum: utils.getSeconds(endOfDay)\n      };\n    },\n    meridiem: function meridiem() {\n      return {\n        minimum: 0,\n        maximum: 0\n      };\n    }\n  };\n};\nvar warnedOnceInvalidSection = false;\nexport var validateSections = function validateSections(sections, valueType) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      var supportedSections = [];\n\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n\n      var invalidSection = sections.find(function (section) {\n        return !supportedSections.includes(section.type);\n      });\n\n      if (invalidSection) {\n        console.warn(\"MUI: The field component you are using is not compatible with the \\\"\".concat(invalidSection.type, \" date section.\"), \"The supported date sections are [\\\"\".concat(supportedSections.join('\", \"'), \"\\\"]`.\"));\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\n\nvar transferDateSectionValue = function transferDateSectionValue(utils, timezone, section, dateToTransferFrom, dateToTransferTo) {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n\n    case 'weekDay':\n      {\n        var formattedDaysInWeek = getDaysInWeekStr(utils, timezone, section.format);\n        var dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        var dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        var dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        var diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n\n    case 'meridiem':\n      {\n        var isAM = utils.getHours(dateToTransferFrom) < 12;\n        var mergedDateHours = utils.getHours(dateToTransferTo);\n\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n\n        return dateToTransferTo;\n      }\n\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\n\nvar reliableSectionModificationOrder = {\n  year: 1,\n  month: 2,\n  day: 3,\n  weekDay: 4,\n  hours: 5,\n  minutes: 6,\n  seconds: 7,\n  meridiem: 8\n};\nexport var mergeDateIntoReferenceDate = function mergeDateIntoReferenceDate(utils, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) {\n  return (// cloning sections before sort to avoid mutating it\n    _toConsumableArray(sections).sort(function (a, b) {\n      return reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type];\n    }).reduce(function (mergedDate, section) {\n      if (!shouldLimitToEditedSections || section.modified) {\n        return transferDateSectionValue(utils, timezone, section, dateToTransferFrom, mergedDate);\n      }\n\n      return mergedDate;\n    }, referenceDate)\n  );\n};\nexport var isAndroid = function isAndroid() {\n  return navigator.userAgent.toLowerCase().indexOf('android') > -1;\n};\nexport var getSectionOrder = function getSectionOrder(sections, isRTL) {\n  var neighbors = {};\n\n  if (!isRTL) {\n    sections.forEach(function (_, index) {\n      var leftIndex = index === 0 ? null : index - 1;\n      var rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex: leftIndex,\n        rightIndex: rightIndex\n      };\n    });\n    return {\n      neighbors: neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n\n  var rtl2ltr = {};\n  var ltr2rtl = {};\n  var groupedSectionsStart = 0;\n  var groupedSectionsEnd = 0;\n  var RTLIndex = sections.length - 1;\n\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex( // eslint-disable-next-line @typescript-eslint/no-loop-func\n    function (section, index) {\n      var _section$endSeparator;\n\n      return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(' ')) && // Special case where the spaces were not there in the initial input\n      section.endSeparator !== ' / ';\n    });\n\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n\n    for (var i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n\n  sections.forEach(function (_, index) {\n    var rtlIndex = ltr2rtl[index];\n    var leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    var rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex: leftIndex,\n      rightIndex: rightIndex\n    };\n  });\n  return {\n    neighbors: neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};","map":null,"metadata":{},"sourceType":"module"}