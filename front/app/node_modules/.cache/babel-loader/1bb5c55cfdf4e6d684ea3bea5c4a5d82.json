{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Namespace = exports.Socket = exports.Server = void 0;\n\nvar http = require(\"http\");\n\nvar fs_1 = require(\"fs\");\n\nvar zlib_1 = require(\"zlib\");\n\nvar accepts = require(\"accepts\");\n\nvar stream_1 = require(\"stream\");\n\nvar path = require(\"path\");\n\nvar engine_io_1 = require(\"engine.io\");\n\nvar client_1 = require(\"./client\");\n\nvar events_1 = require(\"events\");\n\nvar namespace_1 = require(\"./namespace\");\n\nObject.defineProperty(exports, \"Namespace\", {\n  enumerable: true,\n  get: function get() {\n    return namespace_1.Namespace;\n  }\n});\n\nvar parent_namespace_1 = require(\"./parent-namespace\");\n\nvar socket_io_adapter_1 = require(\"socket.io-adapter\");\n\nvar parser = __importStar(require(\"socket.io-parser\"));\n\nvar debug_1 = __importDefault(require(\"debug\"));\n\nvar socket_1 = require(\"./socket\");\n\nObject.defineProperty(exports, \"Socket\", {\n  enumerable: true,\n  get: function get() {\n    return socket_1.Socket;\n  }\n});\n\nvar typed_events_1 = require(\"./typed-events\");\n\nvar uws_1 = require(\"./uws\");\n\nvar debug = (0, debug_1.default)(\"socket.io:server\");\n\nvar clientVersion = require(\"../package.json\").version;\n\nvar dotMapRegex = /\\.map/;\n\nvar Server = /*#__PURE__*/function (_typed_events_1$Stric) {\n  _inherits(Server, _typed_events_1$Stric);\n\n  function Server(srv) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Server);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Server).call(this));\n    /**\n     * @private\n     */\n\n    _this._nsps = new Map();\n    _this.parentNsps = new Map();\n\n    if (\"object\" === typeof srv && srv instanceof Object && !srv.listen) {\n      opts = srv;\n      srv = undefined;\n    }\n\n    _this.path(opts.path || \"/socket.io\");\n\n    _this.connectTimeout(opts.connectTimeout || 45000);\n\n    _this.serveClient(false !== opts.serveClient);\n\n    _this._parser = opts.parser || parser;\n    _this.encoder = new _this._parser.Encoder();\n\n    _this.adapter(opts.adapter || socket_io_adapter_1.Adapter);\n\n    _this.sockets = _this.of(\"/\");\n    _this.opts = opts;\n    if (srv || typeof srv == \"number\") _this.attach(srv);\n    return _this;\n  }\n\n  _createClass(Server, [{\n    key: \"serveClient\",\n    value: function serveClient(v) {\n      if (!arguments.length) return this._serveClient;\n      this._serveClient = v;\n      return this;\n    }\n    /**\n     * Executes the middleware for an incoming namespace not already created on the server.\n     *\n     * @param name - name of incoming namespace\n     * @param auth - the auth parameters\n     * @param fn - callback\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_checkNamespace\",\n    value: function _checkNamespace(name, auth, fn) {\n      var _this2 = this;\n\n      if (this.parentNsps.size === 0) return fn(false);\n      var keysIterator = this.parentNsps.keys();\n\n      var run = function run() {\n        var nextFn = keysIterator.next();\n\n        if (nextFn.done) {\n          return fn(false);\n        }\n\n        nextFn.value(name, auth, function (err, allow) {\n          if (err || !allow) {\n            return run();\n          }\n\n          if (_this2._nsps.has(name)) {\n            // the namespace was created in the meantime\n            debug(\"dynamic namespace %s already exists\", name);\n            return fn(_this2._nsps.get(name));\n          }\n\n          var namespace = _this2.parentNsps.get(nextFn.value).createChild(name);\n\n          debug(\"dynamic namespace %s was created\", name); // @ts-ignore\n\n          _this2.sockets.emitReserved(\"new_namespace\", namespace);\n\n          fn(namespace);\n        });\n      };\n\n      run();\n    }\n  }, {\n    key: \"path\",\n    value: function path(v) {\n      if (!arguments.length) return this._path;\n      this._path = v.replace(/\\/$/, \"\");\n\n      var escapedPath = this._path.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n\n      this.clientPathRegex = new RegExp(\"^\" + escapedPath + \"/socket\\\\.io(\\\\.msgpack|\\\\.esm)?(\\\\.min)?\\\\.js(\\\\.map)?(?:\\\\?|$)\");\n      return this;\n    }\n  }, {\n    key: \"connectTimeout\",\n    value: function connectTimeout(v) {\n      if (v === undefined) return this._connectTimeout;\n      this._connectTimeout = v;\n      return this;\n    }\n  }, {\n    key: \"adapter\",\n    value: function adapter(v) {\n      if (!arguments.length) return this._adapter;\n      this._adapter = v;\n\n      var _iterator = _createForOfIteratorHelper(this._nsps.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var nsp = _step.value;\n\n          nsp._initAdapter();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return this;\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     * @public\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(srv) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.attach(srv, opts);\n    }\n    /**\n     * Attaches socket.io to a server or port.\n     *\n     * @param srv - server or port\n     * @param opts - options passed to engine.io\n     * @return self\n     * @public\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(srv) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (\"function\" == typeof srv) {\n        var msg = \"You are trying to attach socket.io to an express \" + \"request handler function. Please pass a http.Server instance.\";\n        throw new Error(msg);\n      } // handle a port as a string\n\n\n      if (Number(srv) == srv) {\n        srv = Number(srv);\n      }\n\n      if (\"number\" == typeof srv) {\n        debug(\"creating http server and binding to %d\", srv);\n        var port = srv;\n        srv = http.createServer(function (req, res) {\n          res.writeHead(404);\n          res.end();\n        });\n        srv.listen(port);\n      } // merge the options passed to the Socket.IO server\n\n\n      Object.assign(opts, this.opts); // set engine.io path to `/socket.io`\n\n      opts.path = opts.path || this._path;\n      this.initEngine(srv, opts);\n      return this;\n    }\n  }, {\n    key: \"attachApp\",\n    value: function attachApp(app\n    /*: TemplatedApp */\n    ) {\n      var _this3 = this;\n\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // merge the options passed to the Socket.IO server\n      Object.assign(opts, this.opts); // set engine.io path to `/socket.io`\n\n      opts.path = opts.path || this._path; // initialize engine\n\n      debug(\"creating uWebSockets.js-based engine with opts %j\", opts);\n      var engine = new engine_io_1.uServer(opts);\n      engine.attach(app, opts); // bind to engine events\n\n      this.bind(engine);\n\n      if (this._serveClient) {\n        // attach static file serving\n        app.get(\"\".concat(this._path, \"/*\"), function (res, req) {\n          if (!_this3.clientPathRegex.test(req.getUrl())) {\n            req.setYield(true);\n            return;\n          }\n\n          var filename = req.getUrl().replace(_this3._path, \"\").replace(/\\?.*$/, \"\").replace(/^\\//, \"\");\n          var isMap = dotMapRegex.test(filename);\n          var type = isMap ? \"map\" : \"source\"; // Per the standard, ETags must be quoted:\n          // https://tools.ietf.org/html/rfc7232#section-2.3\n\n          var expectedEtag = '\"' + clientVersion + '\"';\n          var weakEtag = \"W/\" + expectedEtag;\n          var etag = req.getHeader(\"if-none-match\");\n\n          if (etag) {\n            if (expectedEtag === etag || weakEtag === etag) {\n              debug(\"serve client %s 304\", type);\n              res.writeStatus(\"304 Not Modified\");\n              res.end();\n              return;\n            }\n          }\n\n          debug(\"serve client %s\", type);\n          res.writeHeader(\"cache-control\", \"public, max-age=0\");\n          res.writeHeader(\"content-type\", \"application/\" + (isMap ? \"json\" : \"javascript\"));\n          res.writeHeader(\"etag\", expectedEtag);\n          var filepath = path.join(__dirname, \"../client-dist/\", filename);\n          (0, uws_1.serveFile)(res, filepath);\n        });\n      }\n\n      (0, uws_1.patchAdapter)(app);\n    }\n    /**\n     * Initialize engine\n     *\n     * @param srv - the server to attach to\n     * @param opts - options passed to engine.io\n     * @private\n     */\n\n  }, {\n    key: \"initEngine\",\n    value: function initEngine(srv, opts) {\n      // initialize engine\n      debug(\"creating engine.io instance with opts %j\", opts);\n      this.eio = (0, engine_io_1.attach)(srv, opts); // attach static file serving\n\n      if (this._serveClient) this.attachServe(srv); // Export http server\n\n      this.httpServer = srv; // bind to engine events\n\n      this.bind(this.eio);\n    }\n    /**\n     * Attaches the static file serving.\n     *\n     * @param srv http server\n     * @private\n     */\n\n  }, {\n    key: \"attachServe\",\n    value: function attachServe(srv) {\n      var _this4 = this;\n\n      debug(\"attaching client serving req handler\");\n      var evs = srv.listeners(\"request\").slice(0);\n      srv.removeAllListeners(\"request\");\n      srv.on(\"request\", function (req, res) {\n        if (_this4.clientPathRegex.test(req.url)) {\n          _this4.serve(req, res);\n        } else {\n          for (var i = 0; i < evs.length; i++) {\n            evs[i].call(srv, req, res);\n          }\n        }\n      });\n    }\n    /**\n     * Handles a request serving of client source and map\n     *\n     * @param req\n     * @param res\n     * @private\n     */\n\n  }, {\n    key: \"serve\",\n    value: function serve(req, res) {\n      var filename = req.url.replace(this._path, \"\").replace(/\\?.*$/, \"\");\n      var isMap = dotMapRegex.test(filename);\n      var type = isMap ? \"map\" : \"source\"; // Per the standard, ETags must be quoted:\n      // https://tools.ietf.org/html/rfc7232#section-2.3\n\n      var expectedEtag = '\"' + clientVersion + '\"';\n      var weakEtag = \"W/\" + expectedEtag;\n      var etag = req.headers[\"if-none-match\"];\n\n      if (etag) {\n        if (expectedEtag === etag || weakEtag === etag) {\n          debug(\"serve client %s 304\", type);\n          res.writeHead(304);\n          res.end();\n          return;\n        }\n      }\n\n      debug(\"serve client %s\", type);\n      res.setHeader(\"Cache-Control\", \"public, max-age=0\");\n      res.setHeader(\"Content-Type\", \"application/\" + (isMap ? \"json\" : \"javascript\"));\n      res.setHeader(\"ETag\", expectedEtag);\n      Server.sendFile(filename, req, res);\n    }\n    /**\n     * @param filename\n     * @param req\n     * @param res\n     * @private\n     */\n\n  }, {\n    key: \"bind\",\n\n    /**\n     * Binds socket.io to an engine.io instance.\n     *\n     * @param {engine.Server} engine engine.io (or compatible) server\n     * @return self\n     * @public\n     */\n    value: function bind(engine) {\n      this.engine = engine;\n      this.engine.on(\"connection\", this.onconnection.bind(this));\n      return this;\n    }\n    /**\n     * Called with each incoming transport connection.\n     *\n     * @param {engine.Socket} conn\n     * @return self\n     * @private\n     */\n\n  }, {\n    key: \"onconnection\",\n    value: function onconnection(conn) {\n      debug(\"incoming connection with id %s\", conn.id);\n      var client = new client_1.Client(this, conn);\n\n      if (conn.protocol === 3) {\n        // @ts-ignore\n        client.connect(\"/\");\n      }\n\n      return this;\n    }\n    /**\n     * Looks up a namespace.\n     *\n     * @param {String|RegExp|Function} name nsp name\n     * @param fn optional, nsp `connection` ev handler\n     * @public\n     */\n\n  }, {\n    key: \"of\",\n    value: function of(name, fn) {\n      if (typeof name === \"function\" || name instanceof RegExp) {\n        var parentNsp = new parent_namespace_1.ParentNamespace(this);\n        debug(\"initializing parent namespace %s\", parentNsp.name);\n\n        if (typeof name === \"function\") {\n          this.parentNsps.set(name, parentNsp);\n        } else {\n          this.parentNsps.set(function (nsp, conn, next) {\n            return next(null, name.test(nsp));\n          }, parentNsp);\n        }\n\n        if (fn) {\n          // @ts-ignore\n          parentNsp.on(\"connect\", fn);\n        }\n\n        return parentNsp;\n      }\n\n      if (String(name)[0] !== \"/\") name = \"/\" + name;\n\n      var nsp = this._nsps.get(name);\n\n      if (!nsp) {\n        debug(\"initializing namespace %s\", name);\n        nsp = new namespace_1.Namespace(this, name);\n\n        this._nsps.set(name, nsp);\n\n        if (name !== \"/\") {\n          // @ts-ignore\n          this.sockets.emitReserved(\"new_namespace\", nsp);\n        }\n      }\n\n      if (fn) nsp.on(\"connect\", fn);\n      return nsp;\n    }\n    /**\n     * Closes server connection\n     *\n     * @param [fn] optional, called as `fn([err])` on error OR all conns closed\n     * @public\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(fn) {\n      var _iterator2 = _createForOfIteratorHelper(this.sockets.sockets.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var socket = _step2.value;\n\n          socket._onclose(\"server shutting down\");\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.engine.close(); // restore the Adapter prototype\n\n      (0, uws_1.restoreAdapter)();\n\n      if (this.httpServer) {\n        this.httpServer.close(fn);\n      } else {\n        fn && fn();\n      }\n    }\n    /**\n     * Sets up namespace middleware.\n     *\n     * @return self\n     * @public\n     */\n\n  }, {\n    key: \"use\",\n    value: function use(fn) {\n      this.sockets.use(fn);\n      return this;\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param room\n     * @return self\n     * @public\n     */\n\n  }, {\n    key: \"to\",\n    value: function to(room) {\n      return this.sockets.to(room);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param room\n     * @return self\n     * @public\n     */\n\n  }, {\n    key: \"in\",\n    value: function _in(room) {\n      return this.sockets.in(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @param name\n     * @return self\n     * @public\n     */\n\n  }, {\n    key: \"except\",\n    value: function except(name) {\n      return this.sockets.except(name);\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * @return self\n     * @public\n     */\n\n  }, {\n    key: \"send\",\n    value: function send() {\n      var _this$sockets;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_this$sockets = this.sockets).emit.apply(_this$sockets, [\"message\"].concat(args));\n\n      return this;\n    }\n    /**\n     * Sends a `message` event to all clients.\n     *\n     * @return self\n     * @public\n     */\n\n  }, {\n    key: \"write\",\n    value: function write() {\n      var _this$sockets2;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      (_this$sockets2 = this.sockets).emit.apply(_this$sockets2, [\"message\"].concat(args));\n\n      return this;\n    }\n    /**\n     * Emit a packet to other Socket.IO servers\n     *\n     * @param ev - the event name\n     * @param args - an array of arguments, which may include an acknowledgement callback at the end\n     * @public\n     */\n\n  }, {\n    key: \"serverSideEmit\",\n    value: function serverSideEmit(ev) {\n      var _this$sockets3;\n\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      return (_this$sockets3 = this.sockets).serverSideEmit.apply(_this$sockets3, [ev].concat(args));\n    }\n    /**\n     * Gets a list of socket ids.\n     *\n     * @public\n     */\n\n  }, {\n    key: \"allSockets\",\n    value: function allSockets() {\n      return this.sockets.allSockets();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     * @public\n     */\n\n  }, {\n    key: \"compress\",\n    value: function compress(_compress) {\n      return this.sockets.compress(_compress);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyâ€™re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @return self\n     * @public\n     */\n\n  }, {\n    key: \"timeout\",\n\n    /**\n     * Adds a timeout in milliseconds for the next operation\n     *\n     * <pre><code>\n     *\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   // ...\n     * });\n     *\n     * </pre></code>\n     *\n     * @param timeout\n     */\n    value: function timeout(_timeout) {\n      return this.sockets.timeout(_timeout);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @public\n     */\n\n  }, {\n    key: \"fetchSockets\",\n    value: function fetchSockets() {\n      return this.sockets.fetchSockets();\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param room\n     * @public\n     */\n\n  }, {\n    key: \"socketsJoin\",\n    value: function socketsJoin(room) {\n      return this.sockets.socketsJoin(room);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param room\n     * @public\n     */\n\n  }, {\n    key: \"socketsLeave\",\n    value: function socketsLeave(room) {\n      return this.sockets.socketsLeave(room);\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param close - whether to close the underlying connection\n     * @public\n     */\n\n  }, {\n    key: \"disconnectSockets\",\n    value: function disconnectSockets() {\n      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this.sockets.disconnectSockets(close);\n    }\n  }, {\n    key: \"volatile\",\n    get: function get() {\n      return this.sockets.volatile;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @return self\n     * @public\n     */\n\n  }, {\n    key: \"local\",\n    get: function get() {\n      return this.sockets.local;\n    }\n  }], [{\n    key: \"sendFile\",\n    value: function sendFile(filename, req, res) {\n      var readStream = (0, fs_1.createReadStream)(path.join(__dirname, \"../client-dist/\", filename));\n      var encoding = accepts(req).encodings([\"br\", \"gzip\", \"deflate\"]);\n\n      var onError = function onError(err) {\n        if (err) {\n          res.end();\n        }\n      };\n\n      switch (encoding) {\n        case \"br\":\n          res.writeHead(200, {\n            \"content-encoding\": \"br\"\n          });\n          readStream.pipe((0, zlib_1.createBrotliCompress)()).pipe(res);\n          (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);\n          break;\n\n        case \"gzip\":\n          res.writeHead(200, {\n            \"content-encoding\": \"gzip\"\n          });\n          (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);\n          break;\n\n        case \"deflate\":\n          res.writeHead(200, {\n            \"content-encoding\": \"deflate\"\n          });\n          (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);\n          break;\n\n        default:\n          res.writeHead(200);\n          (0, stream_1.pipeline)(readStream, res, onError);\n      }\n    }\n  }]);\n\n  return Server;\n}(typed_events_1.StrictEventEmitter);\n\nexports.Server = Server;\n/**\n * Expose main namespace (/).\n */\n\nvar emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function (key) {\n  return typeof events_1.EventEmitter.prototype[key] === \"function\";\n});\nemitterMethods.forEach(function (fn) {\n  Server.prototype[fn] = function () {\n    return this.sockets[fn].apply(this.sockets, arguments);\n  };\n});\n\nmodule.exports = function (srv, opts) {\n  return new Server(srv, opts);\n};\n\nmodule.exports.Server = Server;\nmodule.exports.Namespace = namespace_1.Namespace;\nmodule.exports.Socket = socket_1.Socket;\n\nvar socket_2 = require(\"./socket\");","map":null,"metadata":{},"sourceType":"script"}