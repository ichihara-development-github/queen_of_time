{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RemoteSocket = exports.BroadcastOperator = void 0;\n\nvar socket_1 = require(\"./socket\");\n\nvar socket_io_parser_1 = require(\"socket.io-parser\");\n\nvar BroadcastOperator = /*#__PURE__*/function () {\n  function BroadcastOperator(adapter) {\n    var rooms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    var exceptRooms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, BroadcastOperator);\n\n    this.adapter = adapter;\n    this.rooms = rooms;\n    this.exceptRooms = exceptRooms;\n    this.flags = flags;\n  }\n  /**\n   * Targets a room when emitting.\n   *\n   * @param room\n   * @return a new BroadcastOperator instance\n   * @public\n   */\n\n\n  _createClass(BroadcastOperator, [{\n    key: \"to\",\n    value: function to(room) {\n      var rooms = new Set(this.rooms);\n\n      if (Array.isArray(room)) {\n        room.forEach(function (r) {\n          return rooms.add(r);\n        });\n      } else {\n        rooms.add(room);\n      }\n\n      return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);\n    }\n    /**\n     * Targets a room when emitting.\n     *\n     * @param room\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n\n  }, {\n    key: \"in\",\n    value: function _in(room) {\n      return this.to(room);\n    }\n    /**\n     * Excludes a room when emitting.\n     *\n     * @param room\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n\n  }, {\n    key: \"except\",\n    value: function except(room) {\n      var exceptRooms = new Set(this.exceptRooms);\n\n      if (Array.isArray(room)) {\n        room.forEach(function (r) {\n          return exceptRooms.add(r);\n        });\n      } else {\n        exceptRooms.add(room);\n      }\n\n      return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n\n  }, {\n    key: \"compress\",\n    value: function compress(_compress) {\n      var flags = Object.assign({}, this.flags, {\n        compress: _compress\n      });\n      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because theyâ€™re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n\n  }, {\n    key: \"timeout\",\n\n    /**\n     * Adds a timeout in milliseconds for the next operation\n     *\n     * <pre><code>\n     *\n     * io.timeout(1000).emit(\"some-event\", (err, responses) => {\n     *   // ...\n     * });\n     *\n     * </pre></code>\n     *\n     * @param timeout\n     */\n    value: function timeout(_timeout) {\n      var flags = Object.assign({}, this.flags, {\n        timeout: _timeout\n      });\n      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Emits to all clients.\n     *\n     * @return Always true\n     * @public\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(ev) {\n      var _this = this;\n\n      if (socket_1.RESERVED_EVENTS.has(ev)) {\n        throw new Error(\"\\\"\".concat(String(ev), \"\\\" is a reserved event name\"));\n      } // set up packet object\n\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var data = [ev].concat(args);\n      var packet = {\n        type: socket_io_parser_1.PacketType.EVENT,\n        data: data\n      };\n      var withAck = typeof data[data.length - 1] === \"function\";\n\n      if (!withAck) {\n        this.adapter.broadcast(packet, {\n          rooms: this.rooms,\n          except: this.exceptRooms,\n          flags: this.flags\n        });\n        return true;\n      }\n\n      var ack = data.pop();\n      var timedOut = false;\n      var responses = [];\n      var timer = setTimeout(function () {\n        timedOut = true;\n        ack.apply(_this, [new Error(\"operation has timed out\"), responses]);\n      }, this.flags.timeout);\n      var expectedServerCount = -1;\n      var actualServerCount = 0;\n      var expectedClientCount = 0;\n\n      var checkCompleteness = function checkCompleteness() {\n        if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {\n          clearTimeout(timer);\n          ack.apply(_this, [null, responses]);\n        }\n      };\n\n      this.adapter.broadcastWithAck(packet, {\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      }, function (clientCount) {\n        // each Socket.IO server in the cluster sends the number of clients that were notified\n        expectedClientCount += clientCount;\n        actualServerCount++;\n        checkCompleteness();\n      }, function (clientResponse) {\n        // each client sends an acknowledgement\n        responses.push(clientResponse);\n        checkCompleteness();\n      });\n      this.adapter.serverCount().then(function (serverCount) {\n        expectedServerCount = serverCount;\n        checkCompleteness();\n      });\n      return true;\n    }\n    /**\n     * Gets a list of clients.\n     *\n     * @public\n     */\n\n  }, {\n    key: \"allSockets\",\n    value: function allSockets() {\n      if (!this.adapter) {\n        throw new Error(\"No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?\");\n      }\n\n      return this.adapter.sockets(this.rooms);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @public\n     */\n\n  }, {\n    key: \"fetchSockets\",\n    value: function fetchSockets() {\n      var _this2 = this;\n\n      return this.adapter.fetchSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      }).then(function (sockets) {\n        return sockets.map(function (socket) {\n          if (socket instanceof socket_1.Socket) {\n            // FIXME the TypeScript compiler complains about missing private properties\n            return socket;\n          } else {\n            return new RemoteSocket(_this2.adapter, socket);\n          }\n        });\n      });\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param room\n     * @public\n     */\n\n  }, {\n    key: \"socketsJoin\",\n    value: function socketsJoin(room) {\n      this.adapter.addSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param room\n     * @public\n     */\n\n  }, {\n    key: \"socketsLeave\",\n    value: function socketsLeave(room) {\n      this.adapter.delSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      }, Array.isArray(room) ? room : [room]);\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param close - whether to close the underlying connection\n     * @public\n     */\n\n  }, {\n    key: \"disconnectSockets\",\n    value: function disconnectSockets() {\n      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.adapter.disconnectSockets({\n        rooms: this.rooms,\n        except: this.exceptRooms,\n        flags: this.flags\n      }, close);\n    }\n  }, {\n    key: \"volatile\",\n    get: function get() {\n      var flags = Object.assign({}, this.flags, {\n        volatile: true\n      });\n      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @return a new BroadcastOperator instance\n     * @public\n     */\n\n  }, {\n    key: \"local\",\n    get: function get() {\n      var flags = Object.assign({}, this.flags, {\n        local: true\n      });\n      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);\n    }\n  }]);\n\n  return BroadcastOperator;\n}();\n\nexports.BroadcastOperator = BroadcastOperator;\n/**\n * Expose of subset of the attributes and methods of the Socket class\n */\n\nvar RemoteSocket = /*#__PURE__*/function () {\n  function RemoteSocket(adapter, details) {\n    _classCallCheck(this, RemoteSocket);\n\n    this.id = details.id;\n    this.handshake = details.handshake;\n    this.rooms = new Set(details.rooms);\n    this.data = details.data;\n    this.operator = new BroadcastOperator(adapter, new Set([this.id]));\n  }\n\n  _createClass(RemoteSocket, [{\n    key: \"emit\",\n    value: function emit(ev) {\n      var _this$operator;\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return (_this$operator = this.operator).emit.apply(_this$operator, [ev].concat(args));\n    }\n    /**\n     * Joins a room.\n     *\n     * @param {String|Array} room - room or array of rooms\n     * @public\n     */\n\n  }, {\n    key: \"join\",\n    value: function join(room) {\n      return this.operator.socketsJoin(room);\n    }\n    /**\n     * Leaves a room.\n     *\n     * @param {String} room\n     * @public\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave(room) {\n      return this.operator.socketsLeave(room);\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return {Socket} self\n     *\n     * @public\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.operator.disconnectSockets(close);\n      return this;\n    }\n  }]);\n\n  return RemoteSocket;\n}();\n\nexports.RemoteSocket = RemoteSocket;","map":null,"metadata":{},"sourceType":"script"}