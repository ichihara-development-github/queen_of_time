{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/usr/src/app/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Polling = void 0;\n\nvar transport_1 = require(\"../transport\");\n\nvar zlib_1 = require(\"zlib\");\n\nvar accepts = require(\"accepts\");\n\nvar debug_1 = require(\"debug\");\n\nvar debug = (0, debug_1.default)(\"engine:polling\");\nvar compressionMethods = {\n  gzip: zlib_1.createGzip,\n  deflate: zlib_1.createDeflate\n};\n\nvar Polling = /*#__PURE__*/function (_transport_1$Transpor) {\n  _inherits(Polling, _transport_1$Transpor);\n\n  /**\n   * HTTP polling constructor.\n   *\n   * @api public.\n   */\n  function Polling(req) {\n    var _this;\n\n    _classCallCheck(this, Polling);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Polling).call(this, req));\n    _this.closeTimeout = 30 * 1000;\n    return _this;\n  }\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n\n  _createClass(Polling, [{\n    key: \"onRequest\",\n\n    /**\n     * Overrides onRequest.\n     *\n     * @param {http.IncomingMessage}\n     * @api private\n     */\n    value: function onRequest(req) {\n      var res = req.res;\n\n      if (\"GET\" === req.method) {\n        this.onPollRequest(req, res);\n      } else if (\"POST\" === req.method) {\n        this.onDataRequest(req, res);\n      } else {\n        res.writeHead(500);\n        res.end();\n      }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"onPollRequest\",\n    value: function onPollRequest(req, res) {\n      var _this2 = this;\n\n      if (this.req) {\n        debug(\"request overlap\"); // assert: this.res, '.req and .res should be (un)set together'\n\n        this.onError(\"overlap from client\");\n        res.writeHead(500);\n        res.end();\n        return;\n      }\n\n      debug(\"setting request\");\n      this.req = req;\n      this.res = res;\n\n      var onClose = function onClose() {\n        _this2.onError(\"poll connection closed prematurely\");\n      };\n\n      var cleanup = function cleanup() {\n        req.removeListener(\"close\", onClose);\n        _this2.req = _this2.res = null;\n      };\n\n      req.cleanup = cleanup;\n      req.on(\"close\", onClose);\n      this.writable = true;\n      this.emit(\"drain\"); // if we're still writable but had a pending close, trigger an empty send\n\n      if (this.writable && this.shouldClose) {\n        debug(\"triggering empty send to append close packet\");\n        this.send([{\n          type: \"noop\"\n        }]);\n      }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"onDataRequest\",\n    value: function onDataRequest(req, res) {\n      var _this3 = this;\n\n      if (this.dataReq) {\n        // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n        this.onError(\"data request overlap from client\");\n        res.writeHead(500);\n        res.end();\n        return;\n      }\n\n      var isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n\n      if (isBinary && this.protocol === 4) {\n        return this.onError(\"invalid content\");\n      }\n\n      this.dataReq = req;\n      this.dataRes = res;\n      var chunks = isBinary ? Buffer.concat([]) : \"\";\n\n      var cleanup = function cleanup() {\n        req.removeListener(\"data\", onData);\n        req.removeListener(\"end\", onEnd);\n        req.removeListener(\"close\", onClose);\n        _this3.dataReq = _this3.dataRes = chunks = null;\n      };\n\n      var onClose = function onClose() {\n        cleanup();\n\n        _this3.onError(\"data request connection closed prematurely\");\n      };\n\n      var onData = function onData(data) {\n        var contentLength;\n\n        if (isBinary) {\n          chunks = Buffer.concat([chunks, data]);\n          contentLength = chunks.length;\n        } else {\n          chunks += data;\n          contentLength = Buffer.byteLength(chunks);\n        }\n\n        if (contentLength > _this3.maxHttpBufferSize) {\n          res.writeHead(413).end();\n          cleanup();\n        }\n      };\n\n      var onEnd = function onEnd() {\n        _this3.onData(chunks);\n\n        var headers = {\n          // text/html is required instead of text/plain to avoid an\n          // unwanted download dialog on certain user-agents (GH-43)\n          \"Content-Type\": \"text/html\",\n          \"Content-Length\": 2\n        };\n        res.writeHead(200, _this3.headers(req, headers));\n        res.end(\"ok\");\n        cleanup();\n      };\n\n      req.on(\"close\", onClose);\n      if (!isBinary) req.setEncoding(\"utf8\");\n      req.on(\"data\", onData);\n      req.on(\"end\", onEnd);\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param {String} encoded payload\n     * @api private\n     */\n\n  }, {\n    key: \"onData\",\n    value: function onData(data) {\n      var _this4 = this;\n\n      debug('received \"%s\"', data);\n\n      var callback = function callback(packet) {\n        if (\"close\" === packet.type) {\n          debug(\"got xhr close packet\");\n\n          _this4.onClose();\n\n          return false;\n        }\n\n        _this4.onPacket(packet);\n      };\n\n      if (this.protocol === 3) {\n        this.parser.decodePayload(data, callback);\n      } else {\n        this.parser.decodePayload(data).forEach(callback);\n      }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose() {\n      if (this.writable) {\n        // close pending poll request\n        this.send([{\n          type: \"noop\"\n        }]);\n      }\n\n      _get(_getPrototypeOf(Polling.prototype), \"onClose\", this).call(this);\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Object} packet\n     * @api private\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(packets) {\n      var _this5 = this;\n\n      this.writable = false;\n\n      if (this.shouldClose) {\n        debug(\"appending close packet to payload\");\n        packets.push({\n          type: \"close\"\n        });\n        this.shouldClose();\n        this.shouldClose = null;\n      }\n\n      var doWrite = function doWrite(data) {\n        var compress = packets.some(function (packet) {\n          return packet.options && packet.options.compress;\n        });\n\n        _this5.write(data, {\n          compress: compress\n        });\n      };\n\n      if (this.protocol === 3) {\n        this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n      } else {\n        this.parser.encodePayload(packets, doWrite);\n      }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @api private\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(data, options) {\n      var _this6 = this;\n\n      debug('writing \"%s\"', data);\n      this.doWrite(data, options, function () {\n        _this6.req.cleanup();\n      });\n    }\n    /**\n     * Performs the write.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"doWrite\",\n    value: function doWrite(data, options, callback) {\n      var _this7 = this;\n\n      // explicit UTF-8 is required for pages not served under utf\n      var isString = typeof data === \"string\";\n      var contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n      var headers = {\n        \"Content-Type\": contentType\n      };\n\n      var respond = function respond(data) {\n        headers[\"Content-Length\"] = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n\n        _this7.res.writeHead(200, _this7.headers(_this7.req, headers));\n\n        _this7.res.end(data);\n\n        callback();\n      };\n\n      if (!this.httpCompression || !options.compress) {\n        respond(data);\n        return;\n      }\n\n      var len = isString ? Buffer.byteLength(data) : data.length;\n\n      if (len < this.httpCompression.threshold) {\n        respond(data);\n        return;\n      }\n\n      var encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n\n      if (!encoding) {\n        respond(data);\n        return;\n      }\n\n      this.compress(data, encoding, function (err, data) {\n        if (err) {\n          _this7.res.writeHead(500);\n\n          _this7.res.end();\n\n          callback(err);\n          return;\n        }\n\n        headers[\"Content-Encoding\"] = encoding;\n        respond(data);\n      });\n    }\n    /**\n     * Compresses data.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"compress\",\n    value: function compress(data, encoding, callback) {\n      debug(\"compressing\");\n      var buffers = [];\n      var nread = 0;\n      compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function (chunk) {\n        buffers.push(chunk);\n        nread += chunk.length;\n      }).on(\"end\", function () {\n        callback(null, Buffer.concat(buffers, nread));\n      }).end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"doClose\",\n    value: function doClose(fn) {\n      var _this8 = this;\n\n      debug(\"closing\");\n      var closeTimeoutTimer;\n\n      if (this.dataReq) {\n        debug(\"aborting ongoing data request\");\n        this.dataReq.destroy();\n      }\n\n      var onClose = function onClose() {\n        clearTimeout(closeTimeoutTimer);\n        fn();\n\n        _this8.onClose();\n      };\n\n      if (this.writable) {\n        debug(\"transport writable - closing right away\");\n        this.send([{\n          type: \"close\"\n        }]);\n        onClose();\n      } else if (this.discarded) {\n        debug(\"transport discarded - closing right away\");\n        onClose();\n      } else {\n        debug(\"transport not writable - buffering orderly close\");\n        this.shouldClose = onClose;\n        closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n      }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param {http.IncomingMessage} request\n     * @param {Object} extra headers\n     * @api private\n     */\n\n  }, {\n    key: \"headers\",\n    value: function headers(req, _headers) {\n      _headers = _headers || {}; // prevent XSS warnings on IE\n      // https://github.com/LearnBoost/socket.io/pull/1333\n\n      var ua = req.headers[\"user-agent\"];\n\n      if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n        _headers[\"X-XSS-Protection\"] = \"0\";\n      }\n\n      this.emit(\"headers\", _headers, req);\n      return _headers;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return \"polling\";\n    }\n  }, {\n    key: \"supportsFraming\",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return Polling;\n}(transport_1.Transport);\n\nexports.Polling = Polling;","map":null,"metadata":{},"sourceType":"script"}